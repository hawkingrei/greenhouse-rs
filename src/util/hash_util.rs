use std::mem;
// Get 32 more bits of randomness from a 32-bit hash:
#[inline(always)]
pub fn rehash32to32(hash: u32) -> u32 {
    // Constants generated by uuidgen(1) with the -r flag
    let m: u64 = 0x7850f11ec6d14889;
    let a: u64 = 0x6773610597ca4c63;
    // This is strongly universal hashing following Dietzfelbinger's "Universal hashing
    // and k-wise independent random variables via integer arithmetic without primes". As
    // such, for any two distinct uint32_t's hash1 and hash2, the probability (over the
    // randomness of the constants) that any subset of bit positions of
    // Rehash32to32(hash1) is equal to the same subset of bit positions
    // Rehash32to32(hash2) is minimal.
    unsafe {
        let result: [u8; 8] = mem::transmute((hash as u64).wrapping_mul(m).wrapping_add(a));

        return mem::transmute::<[u8; 4], u32>([result[0], result[1], result[2], result[3]]);
    }
}
